Using the following semantics as a starting point, add arrays to the language.

Your extension should support at least int and bool arrays with the following syntax:

- int[10]   returns the  address of an array of 10 integer entries.
- bool[10]  returns the  address of an array of 10 boolean entries.
- at(x, i) returns the ith value of the array referenced by x.
- set(x, i, v) sets the ith value of the array referenced by x and returns the old value.

The type of int[10] is int[].

1. Define a big step operational semantics for the extended language using ott.
2. Give a type system for the extended language using ott.
3. Prove type safety for the language (focus only on the new features).

The assignment is due Thursday 16th.


----

metavar integer_literal ::=  {{ lex numeral }}indexvar index , i , j ::=  {{ lex numeral }}  {{ com index variables }}grammarterminals :: terminals_ ::=  | -->                        ::   :: longrightarrow {{ tex \Downarrow }}  | ->                         ::   :: rightarrow     {{ tex \rightarrow }}  | =>                         ::   :: Rightarrow     {{ tex \Rightarrow }}  | \                          ::   :: lambda         {{ tex \lambda }}  | |->                        ::   :: mapsto         {{ tex \mapsto }}  | |-                         ::   :: vdash          {{ tex \vdash }}  | *                          ::   :: times          {{ tex \times }}  | <                          ::   :: langle         {{ tex \langle }}  | >                          ::   :: rangle         {{ tex \rangle }}  | !                          :: :: ref  | notin                      :: :: notin {{ tex \not\in}} t :: Tm ::=                                        {{ com terms: }}  | true                          ::   :: True      {{ com constant true }}  | false                         ::   :: False     {{ com constant false }}  | if t1 then t2 else t3         ::   :: If        {{ com conditional }}  | x                             ::   :: Var       {{ com variable }}  | \ x : T . t                   ::   :: Abs       {{ com abstraction }}  | t1 t2                         ::   :: App       {{ com application }}  | [ x |-> v ] t                 :: M :: Subst       | nv                            ::   :: Int     {{ com integer }}  | t + t'                        ::   :: Add    {{ com addition }}  | ( t )                         :: M :: Paren  | unit                          :: :: Unit {{ com unit }}  | l                             :: :: Addr {{ com address}}v :: Va ::=                                        {{ com values: }}  | true                          ::   :: True       {{ com true value }}  | false                         ::   :: False      {{ com false value }}  | \ x : T . t                   ::   :: Abs       {{ com abstraction value }}  | nv                            ::   :: Int  {{ com integer value }}  | unit                          :: :: Unit {{ com unit }}  | l                             :: :: Addr {{ com address}}nv :: 'i_' ::= {{ com Integers }}  | integer_literal :: :: Integerl :: 'l_' ::= {{ com address }}  | integer_literal :: :: AddrT, S, U :: Ty ::=                      {{ com types: }}  | T -> T'                      ::   :: Arr        {{ com type of functions }}  | ( T )                        :: M :: Paren      {{ ich [[T]] }}  | Bool                         ::   :: Bool       {{ com type of booleans }}  | Int                          :: :: Int {{com type of integers}}  | Unit                         :: :: UnitG {{ tex \Gamma }} :: G_ ::=                      {{ com contexts: }}  | empty                        ::   :: empty      {{ com empty context }}  | G , x : T                    ::   :: vn         {{ com term variable binding }}m {{ tex \mu }} :: M_ ::=  | empty                        :: :: empty  | m [ l -> v ]                 :: :: bindS {{ tex \Sigma }} :: S_ ::=  | empty :: :: empty  | S [ l -> T ] :: :: bind  formula :: formula_ ::=           {{ com formulas }}    | judgement :: :: judgement    | nv1 + nv2 = nv3 :: :: add    | G |- t : T :: :: x    | m ( l ) = v :: :: xx    | m = m' [ l |-> v ] :: :: x2    | l notin dom ( m ) :: :: x3    | x : T in G          ::   :: xTG         {{ tex [[x]]:[[T]] \in [[G]] }}subrulesv <:: tdefns Jop :: '' ::= defn t , m  --> t' , m' :: :: red :: E_ {{ com Evaluation }} by----------------------------- :: Lam\x:T.t , m --> \x:T.t , m t1,m  --> \x:T.t1', m' t2,m' --> v,m''[x |-> v]t1',m'' --> v' ,m'''----------------- :: Appt1 t2 , m --> v',m'''t1,m --> true,m't2,m' --> v,m''--------------------------- :: IfTif t1 then t2 else t3,m --> v,m''t1,m --> false,m't3,m' --> v,m''--------------------------- :: IfFif t1 then t2 else t3,m --> v,m''t1,m --> nv1,m't2,m' --> nv2,m''nv1 + nv2 = nv3-------------------- :: Plust1 + t2,m  --> nv3,m''--------- :: Valv,m --> v, m